# Team 00 - Go Boot camp

## Случайные пришельцы

## Содержание

1. [Глава I](#chapter-i) \
    1.1. [Основные правила](#general-rules)
2. [Глава II](#chapter-ii) \
    2.1. [Rules of the day](#rules-of-the-day)
3. [Глава III](#chapter-iii) \
    3.1. [Введение](#intro)
4. [Глава IV](#chapter-iv) \
    4.1. [Задача 00: Передатчик](#exercise-00-transmitter)
5. [Глава V](#chapter-v) \
    5.1. [Задача 01: Выявление аномалий](#exercise-01-anomaly-detection)
6. [Глава VI](#chapter-vi) \
    6.1. [Задача 02: Отчет](#exercise-02-report)
7. [Глава VII](#chapter-vii) \
    7.1. [Задача 03: Все вместе](#exercise-03-all-together)
8. [Глава VIII](#chapter-viii) \
    8.1. [Reading](#reading)

<h2 id="chapter-i" >Глава I</h2>
<h2 id="general-rules" >Основные правила</h2>

* Твоя программа не должна закрываться неожиданно (выдавая ошибку при корректном вводе). Если это произойдет, твой проект будет считаться неработаспособным и получит 0 во время оценки.
* Мы рекомендуем тебе писать тесты для твоего проекта, даже если если они и не оцениваются. Это даст тебе возможность легко тестировать твою работу и работу твоих пиров. Ты убедишься что тесты очень полезны, во время защиты. Во время защиты ты свободен использовать свои тесты и/или тесты пира которого ты проверяешь.
* Отправляй свою работу в нужный git репозиторий. Работа будет оцениваться только из git репозитория.
* Если твой код использует сторонние зависимости, следует использовать [Go Modules](https:

<h2 id="chapter-ii" >Глава II</h2>
<h2 id="rules-of-the-day" >Правила дня</h2>

* Пиши код только в `*.go` файлах и (в случае стронних зависимостей) `go.mod` + `go.sum`
* Твой код для этого задания должен собираться с использовния простого `go build`
* Все твои тесты должны запускаться стандартным вызовом `go test ./...`

<h2 id="chapter-iii" >Глава III</h2>
<h2 id="intro" >Введение</h2>

"Мы без понятия как это сделать!" - Луиза почти отчаялась. - "Корабль постоянно меняет частоту!"

Это была вторая бессонная ночь подряд для нее. Все указывало что эти инопрешеленцы пытались связаться с землянами, но главная проблема была это понимания друг друга.

Радиоприемник на столе внезапно включился: "Халперн докладывает. Наши агенты подключили кодирующий девайс к кораблю. Он собирает генерируемые частоты и может отправлять их в бинарном виде по сети. 

Луиза немедленно рванула поближе к экрану, но вероятно устройство передает данные только внутри зашированной военной сети, где никто из научных сотрудников не имеет доступа

На блестящего лингвиста было жалко смотреть. Но через пару минут он тряснула своей головой, словно она пытается прогрнать прочь мысли, и начала злобно вести переговоры с военными по рации. Одновременно ее рука яростно делала заметки на клочке бумаги.

Примерно через час после, она устало опустилась на кресло и просила рацию на стол. Затем оглядела команду.

"Тут кто-нибудь знает как программировать?" - она спросила. "Эти тупицы не хотят давать нам доступ к их устройству. Мы можем сделать что-то подобное и затем они согласятся подключить наш анализатор в их сеть. Но только если мы его протестируем сначала."

"Две или три руки поднялись неуверенно"

"Оки, оно использует нечто, называемое gRPC, что бы это не значило. Наш анализатор должен подключиться и принимать поток частот, смотреть на него и генерировать что-то типа отчета в PostgreSQL. Они мне дали формат данных"

Она встала и прошлась прошлась немного взад-вперед.

"Я поняла что анализирование полностью случайного сигнала это сложная задача. Жаль, что у нас нет больше информации"

И затем радиоприемным включился еще раз. И вещь, услышанная Луизой зажгло ее глаза энтузиазмом. Она глянула на команду и сказала еще одну вещь громким, триумфальным шепетом:

"Я думаю я знаю что делать! ЭТО ЖЕ НОРМАЛЬНОЕ РАСПРЕДЕЛЕНИЕ!"

<h2 id="chapter-iv" >Глава IV</h2>
<h3 id="ex00">Задача 00: Передатчик</h3>

"Так, нам но надо переписать этот проток военного девайся на наш собственный." - Сказала Луиза. - "Я уже отметила что он использует gRPC, так давайте сделаем это."

Она показала базовую схему типов данных. Выглядит так, что каждое сообщение содержит всего три поля:
* `session_id` строкового типа
* `frequency` как число с плавающей точкой двойной точности
* `current_timestamp` текущее число в UTC, как число с плавающей точкой двойной точности

Мы здесь мало что знаем о распределении, поэтому давайте реализуем это таким образом, чтобы всякий раз, когда новый клиент подключается, [ожидаемое значение](https:

На каждое новое соединение сервера должно генерироваться случайное UUID (отправляется как session_id) и новые случайное для среднего и стандартного отклонения. Все сгенерированные значения должны быть записаны в журнал(логи) сервера (стандартный поток вывода или в файл). После этого это должно отправлять поток сущностей, с полями описанными выше, где каждое сообщение в поле 'частота' будет иметь значение выбранное случайно из нормального распределения с этим стандартным отклонением ожидаемого значения.

Все это требуется описать в схеме в `.proto` файле и генеровать код из него. Так же ты не должен модифицировать код вручную, просто импортируй его.

<h2 id="chapter-v" >Глава V</h2>
<h3 id="ex01">Задача 01: Выявление аномалий</h3>

"Теперь перейдем к интересной части! Пока другие работают над gRPC-сервером, давайте подумаем о клиенте. Я полагаю, что с gRPC-клиентом должны работать те же ребята, которые пишут сервер для его тестирования, так что давайте сосредоточимся на другом. Нам нужно обнаружить аномалии в распределении частот!"

Итак, вы знаете, что получаете поток значений. С каждой новой входящей записью из потока ваш код должен иметь возможность аппроксимировать среднее значение и стандартное значение из случайного распределения, сгенерированного на сервере. Конечно, на самом деле невозможно предсказать это, основываясь только на 3-5 значениях, но после 50-100 это должно быть достаточно точно. Имейте в виду, что mean и STD генерируются для каждого нового подключения, поэтому вам не следует перезапускать клиент во время процесса. Кроме того, значения не должны постоянно накапливаться в памяти, поэтому вы можете рассмотреть возможность использования sync.Пул для удобства повторного использования.

Во время работы над этой задачей вы можете временно забыть о gRPC и протестировать код, просто отправив ему последовательность значений в stdin.

Ваш клиентский код должен периодически записывать в журнал, сколько значений обработано на данный момент, а также прогнозируемые значения mean и STD.

Через некоторое время, когда ваш клиент решит, что прогнозируемые параметры распределения достаточно хороши (не стесняйтесь выбирать этот момент самостоятельно), он должен автоматически перейти в стадию обнаружения аномалий. Здесь в игру вступает еще один параметр - *Коэффициент аномалий STD*. Итак, ваш клиент должен принять параметр командной строки (пусть это будет '-k') с коэффициентом с плавающей запятой.

Входящая частота считается аномалией, если она отличается от ожидаемого значения более чем на *k \* STD* в любую сторону (влево или вправо, поскольку распределение симметрично). Вы можете прочитать больше о том, как это работает, перейдя по ссылкам из Главы 4.

На данный момент вам следует просто записывать найденные аномалии в журнал.

<h2 id="chapter-vi" >Глава VI</h2>
<h3 id="ex02">Задача 02: Отчет</h3>

"Поскольку генерал ничего не знает о нашей научной штуковине, давайте сохраним все аномалии, с которыми мы сталкиваемся, в базе данных, и тогда он сможет просмотреть их через какой-нибудь интерфейс, который у них есть", - Луизу, похоже, гораздо больше волнуют данные, а не генерал.

Итак, давайте узнаем, как записывать данные в PostgreSQL. Обычно считается плохой практикой просто писать простые SQL-запросы в коде, когда имеешь дело с высокозащищенными средами (вы можете прочитать о SQL-инъекциях, перейдя по ссылкам из Главы 4). Давайте воспользуемся ORM. В случае с PostgreSQL есть два наиболее очевидных варианта (эти ссылки также приведены ниже), но вы можете выбрать любой другой. Основная идея здесь заключается в том, чтобы в ваших исходных текстах не было строк с SQL-кодом.

Вам нужно будет описать свою запись (session_id, частоту и временную метку) как структуру в Go, а затем использовать ее вместе с ORM для отображения в столбцах базы данных.

<h2 id="chapter-vii" >Глава VII</h2>
<h3 id="ex03">Задача 03: Все вместе</h3>

Итак, когда у нас есть передатчик, приемник, система обнаружения аномалий и ORM, мы можем подключить их друг к другу и объединить в полноценный проект.

Итак, если вы запустите сервер и клиент (PostgreSQL должен быть уже запущен на вашем компьютере), ваш клиент подключится к серверу и получит поток записей, которые он затем будет использовать:

* Сначала для восстановления распределения (mean/STD)
* Во-вторых, через некоторое время начните обнаруживать аномалии на основе указанного коэффициента аномалий STD (я предлагаю вам выбрать его достаточно большим для этого эксперимента, чтобы аномалии случались не слишком часто).
* В-третьих, все аномалии должны быть записаны в базу данных в PostgreSQL с использованием ORM

Если Луиза права, эти аномалии могут быть ключом к первому контакту с инопланетянами. Но это также довольно простой подход для случаев, когда вам нужно обнаружить аномалии в потоке данных, для чего можно эффективно использовать Go.

<h2 id="chapter-viii" >Глава VIII</h2>
<h3 id="reading">Список литературы</h3>

[Normal distribution](https:) <br>
[68-95-99.7 rule](https:) <br>
[SQL Injections](https:) <br>
[go-pg](https:) <br>
[GORM](https:) <br>


